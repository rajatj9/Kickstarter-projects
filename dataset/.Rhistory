plot(function(x) -1.06873 + 5.41132*x + -0.66692*(x*x))
#Part B
pairs(Auto01[,-9]) # scatterplots of all variables in Auto01 except name
cor(Auto01[,-9]) #correlation matrix of variables in Auto01 except name
Default
library(ISLR)
Default
?regsubsets
??regsubsets
x = rnorm(100)
x
e = rnorm(100)
X = rnorm(100)
e = rnorm(100)
Y = 1 + 2X + 3*X*X + 4*X*X*X + e
Y = 1 + 2*X + 3*X*X + 4*X*X*X + e
Y = 1 + 2*X + 3*X*X + 4*X*X*X + e
data = data.frame(X,Y)
plot(data)
set.seed(5462)
X = rnorm(100)
e = rnorm(100)
Y = 1 + 2*X + 3*X*X + 4*X*X*X + e
data = data.frame(X,Y)
data = data.frame(y = Y, x = X)
library(leaps)
X = rnorm(100)
e = rnorm(100)
Y = 1 + 2*X + 3*X*X + 4*X*X*X + e
data = data.frame(y = Y, x = X)
mod.full = regsubsets(y ~ poly(x, 10, raw = T), data = data.full, nvmax = 10)
mod.full = regsubsets(y ~ poly(x, 10, raw = T), data = data, nvmax = 10)
summary(mod.full)
mod.full = regsubsets(y ~ poly(x, 10, raw = T), data = data, nvmax = 10)
summary(mod.full)
??regsubsets
names(summary(mod.full))
set.seed(5462)
library(leaps)
X = rnorm(100)
e = rnorm(100)
Y = 1 + 2*X + 3*X*X + 4*X*X*X + e
data = data.frame(y = Y, x = X)
mod.full = regsubsets(y ~ poly(x, 10, raw = T), data = data, nvmax = 10)
mod.summary = summary(mod.full)
which.min(mod,summary$cp)
which.min(mod.summary$cp)
which.min(mod.summary$bic)
which.min(mod.summary$adjr2)
mod.full = regsubsets(y ~ x + x^2 +x^3 +x^4 +x^5 +x^6 +x^7 +x^8 +x^9 +x^10, data = data, nvmax = 10)
mod.full = regsubsets(y ~ poly(x, 10, raw = T), data = data, nvmax = 10)
mod.summary = summary(mod.full)
which.min(mod.summary$adjr2)
mod.summary = summary(mod.full)
mod.summary
plot(mod.full)
# 6.5.1 Best Subset Selection
# Goal: predict a baseball player???s Salary on the basis of various statistics associated with performance in the previous year.
# Call the ISLR package
library(ISLR)
# View Hitters data
View(Hitters)
# Check variable names
names(Hitters)
# Check column and row numbers (number of variables and observations)
dim(Hitters)
# is.na() is used to identify missing observations
# sum() for counting the number of missing elements
sum(is.na(Hitters$Salary))
# Remove all of the rows that have missing values in any variable
Hitters=na.omit(Hitters)
dim(Hitters)
sum(is.na(Hitters))
# Call the leaps package to perform best subset selection
library(leaps)
# Performs best subset selection by identifying the best model that contains a given number of predictors
# By default, regsubsets() only reports results up to the best 8 variable model.
regfit.full=regsubsets(Salary~.,Hitters)
# Outputs the best set of variables for each model size.
summary(regfit.full)
# Force it to try all possible number of variables
regfit.full=regsubsets(Salary~.,data=Hitters,nvmax=19)
reg.summary=summary(regfit.full)
# Check elements in the object "regsubsets"
names(reg.summary)
# Changes of R-squared
reg.summary$rsq
# Plotting RSS, adjusted R2, Cp, and BIC for all of the models at once
par(mfrow=c(2,2))
plot(reg.summary$rss,xlab="Number of Variables",ylab="RSS",type="l")
plot(reg.summary$adjr2,xlab="Number of Variables",ylab="Adjusted RSq",type="l")
# Identify the location of the maximum point of a vector
which.max(reg.summary$adjr2)
# Plot the maximum point
points(11,reg.summary$adjr2[11], col="red",cex=2,pch=20)
plot(reg.summary$cp,xlab="Number of Variables",ylab="Cp",type='l')
which.min(reg.summary$cp)
points(10,reg.summary$cp[10],col="red",cex=2,pch=20)
which.min(reg.summary$bic)
plot(reg.summary$bic,xlab="Number of Variables",ylab="BIC",type='l')
points(6,reg.summary$bic[6],col="red",cex=2,pch=20)
# Use the built-in plot() command of the regsubset() function
plot(regfit.full,scale="r2")
plot(regfit.full,scale="adjr2")
plot(regfit.full,scale="Cp")
plot(regfit.full,scale="bic")
coef(regfit.full,6)
#####################################################################################################################################
# 6.5.2 Forward and Backward Stepwise Selection
# Perfrom forward stepwise selection
regfit.fwd=regsubsets(Salary~.,data=Hitters,nvmax=19,method="forward")
summary(regfit.fwd)
# Perfrom backward stepwise selection
regfit.bwd=regsubsets(Salary~.,data=Hitters,nvmax=19,method="backward")
summary(regfit.bwd)
# Retrieve coefficient estimates for the 7 variable model
coef(regfit.full,7)
coef(regfit.fwd,7)
coef(regfit.bwd,7)
#####################################################################################################################################
# 6.5.3 Choosing Among Models Using the Validation Set Approach and Cross-Validation
set.seed(1)
# Create a random vector, train, of elements equal to TRUE if the corresponding observation is in the training set, and FALSE otherwise.
train=sample(c(TRUE,FALSE), nrow(Hitters),rep=TRUE)
test=(!train)
regfit.best=regsubsets(Salary~.,data=Hitters[train,],nvmax=19)
# Building an "X" matrix from data
test.mat=model.matrix(Salary~.,data=Hitters[test,])
# Prepare a vector to store values of test MSE
val.errors=rep(NA,19)
for(i in 1:19){
# for each model size i, extract the coefficients from regfit.best for the best model of that size
coefi=coef(regfit.best,id=i)
# compute the predicted values of yhat
pred=test.mat[,names(coefi)]%*%coefi
# Calculate test MSE for a model of size i
val.errors[i]=mean((Hitters$Salary[test]-pred)^2)
}
val.errors
which.min(val.errors)
coef(regfit.best,10)
# Write our own predict method
predict.regsubsets=function(object,newdata,id,...){
form=as.formula(object$call[[2]])
mat=model.matrix(form,newdata)
coefi=coef(object,id=id)
xvars=names(coefi)
mat[,xvars]%*%coefi
}
regfit.best=regsubsets(Salary~.,data=Hitters,nvmax=19)
coef(regfit.best,10)
# Perform 10-fold cross validation
k=10
set.seed(1)
# Allocate each observation to one of k = 10 folds
folds=sample(1:k,nrow(Hitters),replace=TRUE)
# Creat an empty matrix to store the cross validation results
# the (i,j)th element corresponds to the test MSE for the ith cross-validation fold for the best j-variable model
cv.errors=matrix(NA,k,19, dimnames=list(NULL, paste(1:19)))
# The loop which performs cross-validation
for(j in 1:k){
best.fit=regsubsets(Salary~.,data=Hitters[folds!=j,],nvmax=19)
for(i in 1:19){
pred=predict(best.fit,Hitters[folds==j,],id=i)
cv.errors[j,i]=mean( (Hitters$Salary[folds==j]-pred)^2)
}
}
# Average over the columns across the 10 validations
mean.cv.errors=apply(cv.errors,2,mean)
mean.cv.errors
par(mfrow=c(1,1))
plot(mean.cv.errors,type='b')
reg.best=regsubsets(Salary~.,data=Hitters, nvmax=19)
coef(reg.best,11)
x=model.matrix(Salary~.,Hitters)[,-1]
y=Hitters$Salary
library(glmnet)
grid=10^seq(10,-2,length=100)
ridge.mod=glmnet(x,y,alpha=0,lambda=grid)
dim(coef(ridge.mod))
ridge.mod$lambda[50]
coef(ridge.mod)[,50]
sqrt(sum(coef(ridge.mod)[-1,50]^2))
ridge.mod$lambda[60]
coef(ridge.mod)[,60]
sqrt(sum(coef(ridge.mod)[-1,60]^2))
predict(ridge.mod,s=50,type="coefficients")[1:20,]
set.seed(1)
train=sample(1:nrow(x), nrow(x)/2)
test=(-train)
y.test=y[test]
ridge.mod=glmnet(x[train,],y[train],alpha=0,lambda=grid, thresh=1e-12)
ridge.pred=predict(ridge.mod,s=4,newx=x[test,])
mean((ridge.pred-y.test)^2)
mean((mean(y[train])-y.test)^2)
ridge.pred=predict(ridge.mod,s=1e10,newx=x[test,])
mean((ridge.pred-y.test)^2)
ridge.pred=predict(ridge.mod,s=0,newx=x[test,],exact=T)
mean((ridge.pred-y.test)^2)
lm(y~x, subset=train)
predict(ridge.mod,s=0,exact=T,type="coefficients")[1:20,]
set.seed(1)
cv.out=cv.glmnet(x[train,],y[train],alpha=0)
plot(cv.out)
bestlam=cv.out$lambda.min
bestlam
ridge.pred=predict(ridge.mod,s=bestlam,newx=x[test,])
mean((ridge.pred-y.test)^2)
out=glmnet(x,y,alpha=0)
predict(out,type="coefficients",s=bestlam)[1:20,]
lasso.mod=glmnet(x[train,],y[train],alpha=1,lambda=grid)
plot(lasso.mod)
set.seed(1)
cv.out=cv.glmnet(x[train,],y[train],alpha=1)
plot(cv.out)
bestlam=cv.out$lambda.min
lasso.pred=predict(lasso.mod,s=bestlam,newx=x[test,])
mean((lasso.pred-y.test)^2)
out=glmnet(x,y,alpha=1,lambda=grid)
lasso.coef=predict(out,type="coefficients",s=bestlam)[1:20,]
lasso.coef
lasso.coef[lasso.coef!=0]
set.seed(5462)
library(leaps)
X = rnorm(100)
e = rnorm(100)
Y = 1 + X + X*X + X*X*X + e
data.new = data.frame(y = Y, x = X)
??regsubsets
subsets = regsubsets(y~poly(x,10, raw = TRUE),data = data.new,nvmax = 10)
summary(subsets)
which.min(mod.summary$cp)
which.min(summary(subsets)$cp)
which.min(summary(subsets)$bic)
which.min(summary(subsets)$adjr2)
plot(summary(subsets)$cp)
plot(summary(subsets)$cp, type = "l")
plot(summary(subsets)$cp, xlab = "Size of the Subset", ylab ="CP", type = "l")
plot(summary(subsets)$cp, xlab = "Size of the Subset", ylab ="CP", type = "l", pch=20)
plot(summary(subsets)$cp, xlab = "Size of the Subset", ylab ="CP", type = "l")
points(4, mod.summary$cp[4],col = "red")
plot(summary(subsets)$bix, xlab = "Size of the Subset", ylab = "CP", type ="l")
plot(summary(subsets)$bic, xlab = "Size of the Subset", ylab = "CP", type ="l")
points(4, mod.summary$bic[4],col = "red")
plot(summary(subsets)$cp, xlab = "Size of the Subset", ylab ="CP", type = "l")
points(4, summary(subsets)$cp[4],col = "red")
plot(summary(subsets)$bic, xlab = "Size of the Subset", ylab = "CP", type ="l")
points(4, summary(subsets)$bic[4],col = "red")
which.min(summary(subsets)$adjr2)
plot(summary(subsets)$adjr2, xlab = "Size of the Subset", ylab ="CP", type = "l")
points(4, summary(subsets)$adjr2[4],col = "red")
which.max(summary(subsets)$adjr2)
plot(summary(subsets)$adjr2, xlab = "Size of the Subset", ylab ="CP", type = "l")
points(8, summary(subsets)$adjr2[8],col = "red")
coeffecients(subsets, id = 4)
coefficients(subsets, id = 4)
plot(data)
subsets.summary = summary(subsets)
which.min(summary(subsets)$cp)
which.min(summary(subsets)$bic)
which.max(summary(subsets)$adjr2)
plot(summary(subsets)$cp, xlab = "Size of the Subset", ylab ="CP", type = "l")
points(4, summary(subsets)$cp[4],col = "red")
plot(summary(subsets)$bic, xlab = "Size of the Subset", ylab = "CP", type ="l")
points(4, summary(subsets)$bic[4],col = "red")
plot(summary(subsets)$adjr2, xlab = "Size of the Subset", ylab ="CP", type = "l")
points(8, summary(subsets)$adjr2[8],col = "red")
coefficients(subsets, id = 4)
subsets.summary$rsq
# 6.5.1 Best Subset Selection
# Goal: predict a baseball player???s Salary on the basis of various statistics associated with performance in the previous year.
# Call the ISLR package
library(ISLR)
# View Hitters data
View(Hitters)
# Check variable names
names(Hitters)
# Check column and row numbers (number of variables and observations)
dim(Hitters)
# is.na() is used to identify missing observations
# sum() for counting the number of missing elements
sum(is.na(Hitters$Salary))
# Remove all of the rows that have missing values in any variable
Hitters=na.omit(Hitters)
dim(Hitters)
sum(is.na(Hitters))
# Call the leaps package to perform best subset selection
library(leaps)
# Performs best subset selection by identifying the best model that contains a given number of predictors
# By default, regsubsets() only reports results up to the best 8 variable model.
regfit.full=regsubsets(Salary~.,Hitters)
# Outputs the best set of variables for each model size.
summary(regfit.full)
# Force it to try all possible number of variables
regfit.full=regsubsets(Salary~.,data=Hitters,nvmax=19)
reg.summary=summary(regfit.full)
# Check elements in the object "regsubsets"
names(reg.summary)
# Changes of R-squared
reg.summary$rsq
# Plotting RSS, adjusted R2, Cp, and BIC for all of the models at once
par(mfrow=c(2,2))
plot(reg.summary$rss,xlab="Number of Variables",ylab="RSS",type="l")
plot(reg.summary$adjr2,xlab="Number of Variables",ylab="Adjusted RSq",type="l")
# Identify the location of the maximum point of a vector
which.max(reg.summary$adjr2)
# Plot the maximum point
points(11,reg.summary$adjr2[11], col="red",cex=2,pch=20)
plot(reg.summary$cp,xlab="Number of Variables",ylab="Cp",type='l')
which.min(reg.summary$cp)
points(10,reg.summary$cp[10],col="red",cex=2,pch=20)
which.min(reg.summary$bic)
plot(reg.summary$bic,xlab="Number of Variables",ylab="BIC",type='l')
points(6,reg.summary$bic[6],col="red",cex=2,pch=20)
# Use the built-in plot() command of the regsubset() function
plot(regfit.full,scale="r2")
subsets.summary = summary(subsets)
par(mfrow=c(3,1))
which.min(summary(subsets)$cp)
which.min(summary(subsets)$bic)
which.max(summary(subsets)$adjr2)
plot(summary(subsets)$cp, xlab = "Size of the Subset", ylab ="CP", type = "l")
points(4, summary(subsets)$cp[4],col = "red")
plot(summary(subsets)$bic, xlab = "Size of the Subset", ylab = "CP", type ="l")
points(4, summary(subsets)$bic[4],col = "red")
plot(summary(subsets)$adjr2, xlab = "Size of the Subset", ylab ="CP", type = "l")
subsets.summary = summary(subsets)
which.min(summary(subsets)$cp)
which.min(summary(subsets)$bic)
which.max(summary(subsets)$adjr2)
plot(summary(subsets)$cp, xlab = "Size of the Subset", ylab ="CP", type = "l")
points(4, summary(subsets)$cp[4],col = "red")
plot(summary(subsets)$bic, xlab = "Size of the Subset", ylab = "CP", type ="l")
points(4, summary(subsets)$bic[4],col = "red")
plot(summary(subsets)$adjr2, xlab = "Size of the Subset", ylab ="CP", type = "l")
points(8, summary(subsets)$adjr2[8],col = "red")
coefficients(subsets, id = 4)
plot()
rm(list=ls(
))
set.seed(5462)
library(leaps)
X = rnorm(100)
e = rnorm(100)
Y = 1 + X + X*X + X*X*X + e
data.new = data.frame(y = Y, x = X)
plot(data)
subsets = regsubsets(y~poly(x,10, raw = TRUE),data = data.new,nvmax = 10)
subsets.summary = summary(subsets)
which.min(summary(subsets)$cp)
which.min(summary(subsets)$bic)
which.max(summary(subsets)$adjr2)
plot(summary(subsets)$cp, xlab = "Size of the Subset", ylab ="CP", type = "l")
points(4, summary(subsets)$cp[4],col = "red")
plot(summary(subsets)$bic, xlab = "Size of the Subset", ylab = "CP", type ="l")
points(4, summary(subsets)$bic[4],col = "red")
plot(summary(subsets)$adjr2, xlab = "Size of the Subset", ylab ="CP", type = "l")
par(mfrow=c(1,1))
subsets = regsubsets(y~poly(x,10, raw = TRUE),data = data.new,nvmax = 10)
subsets.summary = summary(subsets)
which.min(summary(subsets)$cp)
which.min(summary(subsets)$bic)
which.max(summary(subsets)$adjr2)
plot(summary(subsets)$cp, xlab = "Size of the Subset", ylab ="CP", type = "l")
points(4, summary(subsets)$cp[4],col = "red")
plot(summary(subsets)$bic, xlab = "Size of the Subset", ylab = "CP", type ="l")
points(4, summary(subsets)$bic[4],col = "red")
plot(summary(subsets)$adjr2, xlab = "Size of the Subset", ylab ="CP", type = "l")
points(8, summary(subsets)$adjr2[8],col = "red")
coefficients(subsets, id = 4)
coefficients(subsets, id = 8)
plot(data)
# Part A
X = rnorm(100)
e = rnorm(100)
Y = 1 + X + X*X + X*X*X + e
data.new = data.frame(y = Y, x = X)
plot(data)
plot(data.new)
set.seed(1)
library(leaps)
# Part A
X = rnorm(100)
e = rnorm(100)
Y = 1 + X + X*X + X*X*X + e
data.new = data.frame(y = Y, x = X)
plot(data.new)
par(mfrow=c(1,1))
subsets = regsubsets(y~poly(x,10, raw = TRUE),data = data.new,nvmax = 10)
subsets.summary = summary(subsets)
which.min(summary(subsets)$cp)
which.min(summary(subsets)$bic)
which.max(summary(subsets)$adjr2)
plot(summary(subsets)$cp, xlab = "Size of the Subset", ylab ="CP", type = "l")
points(4, summary(subsets)$cp[4],col = "red")
plot(summary(subsets)$bic, xlab = "Size of the Subset", ylab = "CP", type ="l")
points(3, summary(subsets)$bic[3],col = "red")
plot(summary(subsets)$adjr2, xlab = "Size of the Subset", ylab ="CP", type = "l")
points(4, summary(subsets)$adjr2[4],col = "red")
coefficients(subsets, id = 4)
coefficients(subsets, id = 3)
plot(subsets, scale="cp")
plot(subsets, scale="Cp")
plot(subsets, scale="BIC")
plot(subsets, scale="Cp")
plot(subsets, scale="Bic")
plot(subsets, scale="Cp")
names(subsets)
names(summary(subsets))
plot(subsets, scale="Cp")
plot(subsets, scale="bic")
plot(subsets, scale="adjr2")
#Part D
subsets.fwd = regsubsets(y~poly(x,10, raw = TRUE), data = data.new, nvmax=10, method = "forward")
subsets.summary = summary(subsets.fwd)
subsets.summary
subsets.fwd.summary
#Part D
subsets.fwd = regsubsets(y~poly(x,10, raw = TRUE), data = data.new, nvmax=10, method = "forward")
#Part D
subsets.fwd = regsubsets(y~poly(x,10, raw = TRUE), data = data.new, nvmax=10, method = "forward")
subsets.fwd.summary = summary(subsets.fwd)
subsets.fwd.summary
which.min(subsets.fwd.summary$cp)
which.min(subsets.fwd.summary$bic)
which.max(subsets.fwd.summary$adjr2)
#Part D
subsets.fwd = regsubsets(y~poly(x,10, raw = TRUE), data = data.new, nvmax=10, method = "forward")
subsets.fwd.summary = summary(subsets.fwd)
subsets.fwd.summary
which.min(subsets.fwd.summary$cp)
which.min(subsets.fwd.summary$bic)
which.max(subsets.fwd.summary$adjr2)
plot(subsets.fwd.summary$cp, xlab = "Size of the Subset", ylab ="CP", type = "l")
points(4, subsets.fwd.summary$cp[4],col = "red")
plot(subsets.fwd.summary$bic, xlab = "Size of the Subset", ylab = "CP", type ="l")
points(3, subsets.fwd.summary$bic[3],col = "red")
plot(subsets.fwd.summary$adjr2, xlab = "Size of the Subset", ylab ="CP", type = "l")
points(4, subsets.fwd.summary$adjr2[4],col = "red")
coefficients(subsets, id = 4)
coefficients(subsets, id = 3)
subsets.bwd = regsubsets(y~poly(x,10, raw = TRUE), data = data.new, nvmax=10, method = "backward")
subsets.bwd.summary = summary(subsets.fwd)
subsets.bwd.summary
which.min(subsets.bwd.summary$cp)
which.min(subsets.bwd.summary$bic)
which.max(subsets.bwd.summary$adjr2)
plot(subsets.bwd.summary$cp, xlab = "Size of the Subset", ylab ="CP", type = "l")
points(4, subsets.bwd.summary$cp[4],col = "red")
plot(subsets.bwd.summary$bic, xlab = "Size of the Subset", ylab = "CP", type ="l")
points(3, subsets.bwd.summary$bic[3],col = "red")
plot(subsets.bwd.summary$adjr2, xlab = "Size of the Subset", ylab ="CP", type = "l")
points(4, subsets.bwd.summary$adjr2[4],col = "red")
coefficients(subsets, id = 4)
coefficients(subsets, id = 3)
View(data)
setwd("/Users/pranavtalwar/Desktop/Kickstarter-projects/dataset/")
data = read.csv("kickstarter_data_final.csv")
View(data)
Attach(data)
plot(usd_goal, usd_pledged)
plot(data$usd_goal, data$usd_pledged)
names(data)
datanew = data[(1:1000),]
datanew
plot(datanew$usd_goal, datanew$usd_pledged)
plot(data$usd_goal, data$usd_pledged)
plot(data[usd_goal<1000000]$usd_goal, data[usd_goal<1000000]$usd_pledged)
plot(data[data$usd_goal<1000000]$usd_goal, data[data$usd_goal<1000000]$usd_pledged)
plot(data$usd_pledged, data$state)
plot(data$usd_goal, data$usd_pledged)
plot(data$backers, data$usd_pledged)
plot(log(data$backers), log(data$usd_pledged))
?log
plot(log(data$backers, base = 10), log(data$usd_pledged, base = 10))
plot(data$backers, data$state)
summary(data)
attach(data)
plot(backers[state!="live"], state[state!="live"])
plot(backers_count[state!="live"], state[state!="live"])
data_corrected =  data[state!="live"]
attach(data)
data_corrected =  data[state!="live"]
attach(data)
data_corrected =  data[state!="live"]
data_corrected =  data[data$state!="live"]
View(data)
plot(backers_count[state!="live"], state[state!="live"])
?count
??count
which(data$state == "suspended" && data$disable_communication = "True")
which(data$state == "suspended" && data$disable_communication == "True")
?which
which(data$state == "suspended" && data$disable_communication == TRUE)
which(data$state == "suspended" && data$disable_communication == True)
nrow(data[state=])
nrow(data[state=="suspended"])
attach(data)
nrow(data[state="suspended"])
nrow(data[data$state="suspended"])
nrow(data[data$state=="suspended"])
state=="suspended"
indices = state=="suspended"
indices
data[indices]
nrow(data[data$state=="suspended",])
nrow(data[data$state=="suspended" && disable_communication==TRUE,])
nrow(data[data$disable_communication==TRUE,])
nrow(data[data$disable_communication=="True",])
nrow(data[data$state=="suspended" && disable_communication=="True",])
nrow(data[data$state=="suspended" & disable_communication=="True",])
nrow(data[data$state=="suspended" & disable_communication==TRUE,])
